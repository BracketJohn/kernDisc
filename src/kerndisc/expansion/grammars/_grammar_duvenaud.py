import logging
from typing import List

import gpflow

from ..._kernels import BASE_KERNELS


_IMPLEMENTED_KERNEL_NAMES = ['linear', 'periodic', 'rbf', 'white', 'constant']
_IMPLEMENTED_KERNELS = [BASE_KERNELS[k_name] for k_name in _IMPLEMENTED_KERNEL_NAMES]
_LOGGER = logging.getLogger(__package__)


def expand_kernel(kernel: gpflow.kernels.Kernel) -> List[gpflow.kernels.Kernel]:
    """Generate a list of kernels that represent all possible one step alterations of a kernel.

    All rules for extension are from Appendix C of `Automatic Model Construction with Gaussian Processes`.

    Changepoints and changewindows are not yet implemented.

    Parameters
    ----------
    kernel: gpflow.kernels.Kernel
        GPflow kernel object to be expanded.

    Returns
    -------
    kernel_alterations: List[gpflow.kernels.Kernel]
        All possible one step alterations of a kernel. `linear` should return:
        ```
        [
            'cosine', 'linear', 'matern12', 'matern32', 'matern52', 'periodic', 'rbf', 'white', 'rationalquadratic',  # May be substituted by any other kernel.
            'linear + cosine', 'linear + linear', ..., 'linear + rationalquadratic',  # May be added to any other kernel.
            'linear * cosine', ..., 'linear * rationalquadratic',  # May be multiplied by any other kernel.
            'linear * (cosine + constant)', ..., 'linear * (rationalquadratic + constant)',  # May apply `lax_product`.
        ]
        ```
        If `kernel` were to consist out of products or sums, there would be further alterations:
        ```
        `linear + constant` -> ['linear', 'constant'],  # Splitting sums,
        `linear * constant` -> ['linear', 'constant']  # splitting products.
        ```
        Changepoints and changewindows are not yet implemented.

    """
    kernel_alterations: List[gpflow.kernels.Kernel] = [kernel]

    # C3, C8
    kernel_alterations.extend(base_kernel(1) for base_kernel in _IMPLEMENTED_KERNELS)

    for base_kernel in _IMPLEMENTED_KERNELS:
        kernel_alterations.extend([
            kernel + base_kernel(1),                                  # C1
            kernel * base_kernel(1),                                  # C2
            kernel * (base_kernel(1) + BASE_KERNELS['constant'](1)),  # C11
        ])

    # C9, C10
    kernel_alterations.extend(_expand_combinations(kernel))

    return kernel_alterations


def _expand_combinations(kernel: gpflow.kernels.Kernel) -> List[gpflow.kernels.Kernel]:
    """Search for `+` and `*` in kernel that are splittible.

    Method that looks for `+` and `* ` which can be split apart in the form of:
    ```
    `linear + constant` -> ['linear', 'constant'],  # Splitting sums,
    `linear * constant` -> ['linear', 'constant']   # splitting products.
    `linear * (white + constant)` -> ['linear', 'white + constant']
    ```

    Parameters
    ----------
    kernel: gpflow.kernels.Kernel
        Valid duvenaud kernel, such as `rbf * rq + linear`.

    Returns
    -------
    kernel_alterations: List[gpflow.kernels.Kernel]
        All subexpressions that can be generated by splitting apart `+` and `*` in kernels.

    """
    if isinstance(kernel, (gpflow.kernels.Sum, gpflow.kernels.Product)):
        return kernel.children.values()

    return []
